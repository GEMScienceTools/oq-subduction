def calculate_ruptures(ini_fname, ref_fdr=None):
    """
    :param str ini_fname:
        The name of a .ini file
    """
    #
    # read config file
    config = configparser.ConfigParser()
    config.readfp(open(ini_fname))
    #
    # logging settings
    logging.basicConfig(format='rupture:%(levelname)s:%(message)s')
    #
    # reference folder
    if ref_fdr is None:
        ref_fdr = config.get('main', 'reference_folder')
    #
    # set parameters
    profile_sd_topsl = config.getfloat('main', 'profile_sd_topsl')
    edge_sd_topsl = config.getfloat('main', 'edge_sd_topsl')
    sampling = config.getfloat('main', 'sampling')
    float_strike = config.getfloat('main', 'float_strike')
    float_dip = config.getfloat('main', 'float_dip')
    slab_thickness = config.getfloat('main', 'slab_thickness')
    label = config.get('main', 'label')
    hspa = config.getfloat('main', 'hspa')
    vspa = config.getfloat('main', 'vspa')
    uniform_fraction = config.getfloat('main', 'uniform_fraction')
    #
    # MFD params
    agr = config.getfloat('main', 'agr')
    bgr = config.getfloat('main', 'bgr')
    mmax = config.getfloat('main', 'mmax')
    mmin = config.getfloat('main', 'mmin')
    #
    # set profile folder
    path = config.get('main', 'profile_folder')
    path = os.path.abspath(os.path.join(ref_fdr, path))
    #
    # catalogue
    cat_pickle_fname = config.get('main', 'catalogue_pickle_fname')
    cat_pickle_fname = os.path.abspath(os.path.join(ref_fdr, cat_pickle_fname))
    #
    # output
    hdf5_filename = config.get('main', 'out_hdf5_fname')
    hdf5_filename = os.path.abspath(os.path.join(ref_fdr, hdf5_filename))
    #
    # smoothing output
    out_hdf5_smoothing_fname = config.get('main', 'out_hdf5_smoothing_fname')
    tmps = os.path.join(ref_fdr, out_hdf5_smoothing_fname)
    out_hdf5_smoothing_fname = os.path.abspath(tmps)
    #
    # tectonic regionalisation
    treg_filename = config.get('main', 'treg_fname')
    if not re.search('[a-z]', treg_filename):
        treg_filename = None
    else:
        treg_filename = os.path.abspath(os.path.join(ref_fdr, treg_filename))
    #
    #
    dips = list_of_floats_from_string(config.get('main', 'dips'))
    asprsstr = config.get('main', 'aspect_ratios')
    asprs = dict_of_floats_from_string(asprsstr)
    #
    # magnitude-scaling relationship
    msrstr = config.get('main', 'mag_scaling_relation')
    msrd = get_available_scalerel()
    if msrstr not in msrd.keys():
        raise ValueError('')
    msr = msrd[msrstr]()

    # ------------------------------------------------------------------------
    #
    profiles, pro_fnames = read_profiles(path)
    #
    """
    if logging.getLogger().isEnabledFor(logging.DEBUG):
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        for ipro, (pro, fnme) in enumerate(zip(profiles, pro_fnames)):
            plon = ([x+360 if x<0 else x for x in p.longitude])
            tmp = [[plon, p.latitude, p.depth] for p in pro.points]
 #           tmp = [[p.longitude, p.latitude, p.depth] for p in pro.points]
            tmp = np.array(tmp)
            ax.plot(tmp[:, 0], tmp[:, 1], tmp[:, 2], 'x--b', markersize=2)
            tmps = '{:d}-{:s}'.format(ipro, os.path.basename(fnme))
            ax.text(tmp[0, 0], tmp[0, 1], tmp[0, 2], tmps)
        ax.invert_zaxis()
        ax.view_init(50, 55)
        plt.show()
    """
    #
    # create mesh from profiles
    msh = create_from_profiles(profiles, profile_sd=profile_sd_topsl,
                               edge_sd=edge_sd_topsl)
    #
    # create inslab meshes
    oms = create_inslab_meshes(msh, dips, slab_thickness, sampling)
    #
    # lower mesh
    lmsh = create_lower_surface_mesh(msh, slab_thickness)
    #
    # get min and max values
    milo, mila, mide, malo, mala, made = get_min_max(msh, lmsh)
    #
    # discretizing the slab
    # omsh = Mesh(msh[:, :, 0], msh[:, :, 1], msh[:, :, 2])
    # olmsh = Mesh(lmsh[:, :, 0], lmsh[:, :, 1], lmsh[:, :, 2])

    #
    # this `dlt` value [in degrees] is used to create a buffer around the mesh
    dlt = 5.0
    msh3d = Grid3d(milo-dlt, mila-dlt, mide, malo+dlt, mala+dlt, made, hspa,
                   vspa)
    # mlo, mla, mde = msh3d.select_nodes_within_two_meshesa(omsh, olmsh)
    mlo, mla, mde = msh3d.get_coordinates_vectors()
    #
    # save data on hdf5 file
    if os.path.exists(hdf5_filename):
        os.remove(hdf5_filename)
    fh5 = h5py.File(hdf5_filename, 'w')
    grp_slab = fh5.create_group('slab')
    grp_slab.create_dataset('top', data=msh)
    grp_slab.create_dataset('bot', data=lmsh)
    fh5.close()
    #
    # get catalogue
    catalogue = get_catalogue(cat_pickle_fname, treg_filename, label)
    #
    # smoothing - the output is
    values, smooth = smoothing(mlo, mla, mde, catalogue, hspa, vspa,
                               out_hdf5_smoothing_fname)
    #
    # spatial index
    # r = spatial_index(mlo, mla, mde, catalogue, hspa, vspa)
    r, proj = spatial_index(smooth)
    #
    # magnitude-frequency distribution
    mfd = TruncatedGRMFD(min_mag=mmin, max_mag=mmax, bin_width=0.1,
                         a_val=agr, b_val=bgr)
    # create all the ruptures - the probability of occurrence is for one year
    # in this case
    allrup = create_ruptures(mfd, dips, sampling, msr, asprs, float_strike,
                             float_dip, r, values, oms, 1., hdf5_filename,
                             uniform_fraction, proj)

